---
title: 第三章-垃圾收集器与内存分配策略
description: 第三章-垃圾收集器与内存分配策略
---

# 第三章-垃圾收集器与内存分配策略

## 3.1 概述

垃圾收集需要完成的三件事情：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

## 3.2 对象已死？

### 3.2.1 引用计数算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
概念：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；
任何时刻计数器为零的对象就是不可能再被使用的。

<u>优点</u>：原理简单，判定效率也很高<br>
<u>缺点</u>：占用了一些额外的内存空间来进行计数；有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。

!!! Note "引用计数法的缺陷举例：无法解决对象之间相互循环引用"

    注：这个例子只是展示，要运行出失败的例子要打开GC日志，IDEA是将 `-XX:+PrintGCDetails` 参数单独添加给运行类的vm option，
    其他工具就不知道了，书里面没说这点。但其实跑不跑都一样，懂这个例子要表达的引用计数算法的缺陷就行。

    === "代码"

        ```java
        /**
         * testGC()方法执行后，objA和objB会不会被GC呢？
         *
         * @author zzm
        */
        public class ReferenceCountingGC {

            public Object instance = null;

            private static final int _1MB = 1024 * 1024;

            /**
             * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
             */
            private byte[] bigSize = new byte[2 * _1MB];

            public static void testGC() {
                ReferenceCountingGC objA = new ReferenceCountingGC();
                ReferenceCountingGC objB = new ReferenceCountingGC();
                objA.instance = objB;
                objB.instance = objA;

                objA = null;
                objB = null;

                // 假设在这行发生GC，objA和objB是否能被回收？
                System.gc();
            }
        }
        ```

    === "书上的运行结果"

        ```shell
        [Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K( Heap def new generation total 9216K, used 82K
        [0x00000000055e0000, 0x0000000005fe0000, 0x0000000005fe00 Eden space 8192K, 1% used 
        [0x00000000055e0000, 0x00000000055f4850, 0x0000000005de0000) from space 1024K, 0% used 
        [0x0000000005de0000, 0x0000000005de0000, 0x0000000005ee0000) to space 1024K, 0% used 
        [0x0000000005ee0000, 0x0000000005ee0000, 0x0000000005fe0000) tenured generation total 10240K, used 210K
        [0x0000000005fe0000, 0x00000000069e0000, 0x00000000069e the space 10240K, 2% used 
        [0x0000000005fe0000, 0x0000000006014a18, 0x0000000006014c00, 0x000000000 compacting perm gen total 21248K, used 3016K
        [0x00000000069e0000, 0x0000000007ea0000, 0x000000000bd the space 21248K, 14% used 
        [0x00000000069e0000, 0x0000000006cd2398, 0x0000000006cd2400, 0x000000000 No shared spaces configured.
        ```
    
    === "我自己跑的(jdk1.8.0_351)"

        ```shell
        [GC (System.gc()) [PSYoungGen: 11960K->824K(152576K)] 11960K->832K(500736K), 0.0015322 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
        [Full GC (System.gc()) [PSYoungGen: 824K->0K(152576K)] [ParOldGen: 8K->641K(348160K)] 832K->641K(500736K), [Metaspace: 3245K->3245K(1056768K)], 0.0044283 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
        Heap
        PSYoungGen      total 152576K, used 6554K [0x0000000716180000, 0x0000000720b80000, 0x00000007c0000000)
        eden space 131072K, 5% used [0x0000000716180000,0x00000007167e6808,0x000000071e180000)
        from space 21504K, 0% used [0x000000071e180000,0x000000071e180000,0x000000071f680000)
        to   space 21504K, 0% used [0x000000071f680000,0x000000071f680000,0x0000000720b80000)
        ParOldGen       total 348160K, used 641K [0x00000005c2400000, 0x00000005d7800000, 0x0000000716180000)
        object space 348160K, 0% used [0x00000005c2400000,0x00000005c24a0458,0x00000005d7800000)
        Metaspace       used 3286K, capacity 4564K, committed 4864K, reserved 1056768K
        class space    used 357K, capacity 388K, committed 512K, reserved 1048576K
        ```

    从书上的运行结果中可以清楚看到内存回收日志中包含“4603K->210K”，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，
    这也从侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的。

### 3.2.2 可达性分析算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
这个算法的基本思路就是<wavy>通过一系列称为“`GC Roots`”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索</wavy>，
搜索过程所走过的路径称为“`引用链`”（Reference Chain），<wavy>如果某个对象到 GC Roots 间没有任何引用链相连</wavy>，
或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

<figure markdown="span">
  ![Image title](./img/3/RA.png){ width=500 }
  <figcaption>图：利用可达性分析算法判定对象是否可回收</figcaption>
</figure>

??? Note "了解：哪些对象可作为 GC Roots？"
    1️⃣在<u>虚拟机栈（栈帧中的本地变量表）中引用的对象</u>，譬如各个线程被调用的方法 堆栈中使用到的参数、局部变量、临时变量等。<br>
    2️⃣在<u>方法区中类静态属性引用的对象</u>，譬如 Java 类的引用类型静态变量。<br>
    3️⃣在<u>方法区中常量引用的对象</u>，譬如字符串常量池（String Table）里的引用。<br>
    4️⃣在<u>本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象</u>。<br>
    5️⃣<u>Java 虚拟机内部的引用</u>，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。<br>
    6️⃣<u>所有被同步锁（synchronized 关键字）持有的对象</u>。<br>
    7️⃣反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等

### 3.2.3 再谈引用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
引用分为`强引用`（Strongly Re-ference）、`软引用`（Soft Reference）、`弱引用`（Weak Reference）和`虚引用`（Phantom Reference）4 种。

- `强引用`是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。<wavy>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</wavy>。
- `软引用`是用来描述一些还有用，但非必须的对象。<wavy>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</wavy>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- `弱引用`也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<wavy>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</wavy>。
- `虚引用`也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<wavy>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知<wavy>。

### 3.2.4 生存还是死亡？

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
要真正宣告一个对象死亡，至少要经历两次标记过程：
- 1️⃣如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，<br>
- 2️⃣随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
如何判断是否有必要执行finalize()方法？<wavy>看对象有没有覆盖 finalize()方法，或者 finalize()方法是否已经被虚拟机调用过</wavy>，
都没有，那么虚拟机将这两种情况都视为“没有必要执行”。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
如果一个对象被判定为确有必要执行 finalize() 方法，那么该对象将会被放置在一个名为 F-Queue 的队列之中，
并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。
finalize()方法是对象逃脱死亡命运的最后一次机会。

??? Note "一次对象自我拯救的演示"

    ```java
    /**
     * 此代码演示了两点：
     * 1.对象可以在被GC时自我拯救。
     * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
     *
     * @author zzm
     */
    public class FinalizeEscapeGC {

        public static FinalizeEscapeGC SAVE_HOOK = null;

        public void isAlive() {
            System.out.println("yes, i am still alive :)");
        }

        @Override
        protected void finalize() throws Throwable {
            super.finalize();
            System.out.println("finalize method executed!");
            FinalizeEscapeGC.SAVE_HOOK = this;
        }

        public static void main(String[] args) throws Throwable {
            SAVE_HOOK = new FinalizeEscapeGC();

            //对象第一次成功拯救自己
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, i am dead :(");
            }

            // 下面这段代码与上面的完全相同，但是这次自救却失败了
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, i am dead :(");
            }
        }
    }
    ```

### 3.2.5 回收方法区

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
方法区垃圾收集的“性价比”通常也是比较低的,方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
方法区的垃圾收集主要回收两部分内容：`废弃的常量`和`不再使用的类型`。

判断常量是否回收：已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。

判断类型是否回收：
- <u>该类所有的实例都已经被回收</u>，也就是 Java 堆中不存在该类及其任何派生子类的。
- <u>加载该类的类加载器已经被回收</u>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。
- <u>该类对应的 java.lang.Class 对象没有在任何地方被引用</u>，无法在任何地方通过反射访问该类的方法。

## 3.3 垃圾收集算法

### 3.3.1 分代收集理论

总共介绍了三种假说：前两种：<br>
`弱分代假说`（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
`强分代假说`（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
这两个分代假说都有一个设计原则：收集器应该将 Java 堆划分出不同的区域，
然后<wavy>将回收对象依据其年龄</wavy>（年龄即对象熬过垃圾收集过程的次数）<wavy>分配到不同的区域之中存储</wavy>。
这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。
由这个设计原则衍生出把 Java 堆划分为`新生代`（ Young Generati on ）和`老年代`（ Old Generation ）两个区域的应用[^1]。
其实分代收集并非只是简单划一下内存区域那么容易，它至少存在一个明显的困难：<wavy>对象不是孤立的，对象之间会存在跨代引用/<wavy>。
[^1]: 新生代（Young）、老年代（Old）是 HotSpot 虚拟机，也是现在业界主流的命名方式。在 IBM J9 虚拟机中对应
称为婴儿区（Nursery）和长存区（Tenured），名字不同但其含义是一样的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
`跨代引用假说`（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。
按照前两条假说，存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。
但是这个假说只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GCRoots 进行扫描。

??? Warning "概念"
    为避免产生混淆，在这里统一定义

    - `部分收集`（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：
        - `新生代收集`（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
        - `老年代收集`（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。
        另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集行为。
        -`混合收集`（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行
    - `整堆收集`（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

### 3.3.2 标记-清除算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
算法分为“`标记`”和“`清除`”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来。

缺点：

- <wavy>执行效率不稳定</wavy>，大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
- <wavy>内存空间的碎片化问题</wavy>，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中，
  需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作，甚至`内存泄露`。

<figure markdown="span">
  ![Image title](./img/3/Mark-Sweep.png){ width=500 }
  <figcaption>“标记-清除”算法示意图</figcaption>
</figure>

### 3.3.3 标记-复制算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，
就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。一般用于新生代。

- 优点：实现简单，运行高效
- 缺点：可用内存缩小为了原来的一半，空间浪费。

<figure markdown="span">
  ![Image title](./img/3/Mark-Copy.png){ width=500 }
  <figcaption>“标记-复制”算法示意图</figcaption>
</figure>

!!! Note ""
    改进：`Appel式回收`把新生代分为一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，
    每次分配内存只使用 `Eden` 和其中一块 `Survivor`。发生垃圾搜集时，
    将 `Eden` 和 `Survivor` 中仍然存活的对象一次性复制到另外一块 `Survivor` 空间上，
    然后直接清理掉 `Eden` 和已用过的那块 `Survivor` 空间。<wavy>HotSpot 虚拟机默认 `Eden` 和 `Survivor` 的大小比例是 8∶1</wavy>。

### 3.3.4 标记-整理算法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
一般用于老年代。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，
而是<wavy>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</wavy>。

<figure markdown="span">
  ![Image title](./img/3/Mark-Compact.png){ width=500 }
  <figcaption>“标记-整理”算法示意图</figcaption>
</figure>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
标记-清除算法与标记-整理算法的本质差异在于<wavy>是否需要移动对象</wavy>。如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，
移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行[^2]。
这两种算法各有优劣，无论好坏只能谈适合的场景。
[^2]: 通常标记-清除算法也是需要停顿用户线程来标记、清理可回收对象的，只是停顿时间相对而言要来的短而已。

## 3.4 HotSpot

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
主要做一些前置知识铺垫，如果对这部分内容感到枯燥乏味或者疑惑，不妨先跳过去。就是一些概念的解释。

### 3.4.1 根节点枚举

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
概念：就是可达性分析算法介绍的<wavy>从 GC Roots 集合找引用链</wavy>。<br>
迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。
主流 Java 虚拟机使用的都是`准确式垃圾收集`：在 HotSpot 的解决方案里，是使用一组称为 `OopMap` 的数据结构来达到这个目的。
一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第 11 章）过程中，
也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

### 3.4.2 安全点

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
概念：因为 OopMap 可能导致引用关系变化，将会需要大量的额外存储空间，所以只是在“特定的位置”记录了这些信息，这些位置被称为`安全点`（Safepoint）。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
它决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是<wavy>强制要求必须执行到达安全点后才能够暂停</wavy>。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。
安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。

??? Note "细节"
    还有一个是如何在垃圾收集发生时让所有线程（这里其实不包括执行 JNI 调用的线程）都跑到最近的安全点，然后停顿下来。<br>
    两种方案：

    - `抢先式中断`不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，
    如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。
    - `主动式中断`的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，
    各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

### 3.4.3 安全区域

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
`安全区域`是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。[^3]
它解决了程序“不执行”的时候，没有分配处理器时间的问题。
[^3]: 病句吧？下定义是安全区域是指????的区域，少了宾语吧。

??? Note "具体怎么解决？"
    当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，
    那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，
    它要检查虚拟机是否已经完成了根节点枚举（或者 垃圾收集过程中其他需要暂停用户线程的阶段），
    如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

### 3.4.4 记忆集与卡表

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
为解决对象跨代引用所带来的问题引入记忆集与卡表。<br.
`记忆集`是一种用于记录<wavy>从非收集区域指向收集区域的指针集合</wavy>的抽象数据结构，可以记录全部含跨代引用的对象。
收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
它有三种记忆精度：

- `字长精度`：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的 32 位或 64 位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
- `对象精度`：每个记录精确到一个对象，该对象里有字段含有跨代指针。
- `卡精度`：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
`卡表`就是按照`卡精度`来具体实现的一种记忆集。最简单的形式可以只是一个字节数组

### 3.4.5 写屏障

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
`写屏障`是解决卡表元素如何维护的问题的。
卡表元素何时变脏？有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏；如何变脏？就是使用写屏障。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
写屏障可以看作<wavy>在虚拟机层面对 “引用类型字段赋值”这个动作的 AOP 切面，
在引用对象赋值时会产生一个环形 （Around）通知，供程序执行额外的动作</wavy>，也就是说赋值的前后都在写屏障的覆盖范畴内。
在赋值前的部分的写屏障叫作`写前屏障`（Pre-Write Barrier），在赋值后的则叫作`写后屏障`（Post-Write Barrier）。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
既然可能有更新操作，就有并发安全问题，就有“`伪共享`”（False Sharing）问题。一种简单的解决方案是不采用无条件的写屏障，
而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，

### 3.4.6 并发的可达性分析

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，
这意味着<wavy>必须全程冻结用户线程的运行</wavy>。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
看看就行，了解高级知识：<br>
想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？
为了能解释清楚这个问题，我们引入`三色标记`（Tricolor Marking）[^4]
作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色

[^4]: 三色标记的介绍可参见[跟踪垃圾收集](https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking)。

- 白色：表示对象<u>尚未被垃圾收集器访问过</u>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，
  若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象<u>已经被垃圾收集器访问过</u>，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，
  它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象<u>已经被垃圾收集器访问过</u>，但这个对象上至少存在一个引用还没有被扫描过。


<figure markdown="span">
  ![Image title](./img/3/1.png){ width="500" }
  <figcaption>扫描过程中并发出现“对象消失”问题的示意图</figcaption>
</figure>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Wilson 于 1994 年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。
由此分别产生了两种解决方案：`增量更新`（Incremental Update）和`原始快照`（Snapshot At The Beginning， SATB）。

`「增量更新」`要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，
等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，
黑色对象一旦新插入了指向 白色对象的引用之后，它就变回灰色对象了。<br>
`「原始快照」`要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，
再将这些记录过的引用关系中 的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，
都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。<br>

## 3.5 经典垃圾收集器
