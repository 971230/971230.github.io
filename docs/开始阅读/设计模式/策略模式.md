---
title: 策略模式
description: 介绍策略模式的三种使用方式
status: new
---

# 策略模式

![图片的样式](..\img\strategy-2x.png)

## ❶单纯策略模式，没有结合其他设计模式
<P style="text-indent:2em;">
感觉策略模式更适合在实际开发中，有类似的业务，但是有不同的进入情况，可以是业务需要也可以是逻辑需要,
这个模式对于代码，可以简化业务逻辑，不至于将代码写成一坨，长长的几十上百行，最典型的场景，就是if条件的逻辑判断简化。
</p>

!!!但是它也有缺点
    1️⃣如果 if-else的判断情况很多，那么对应的具体策略实现类也会很多</br>
    2️⃣没法俯视整个分派的业务逻辑，因为具体的逻辑被分拆</br>

<P style="text-indent:2em;">
一次面试中，阿里面试官提到策略模式，他不这样认为，觉得都是一样需要看很多分支逻辑的，无论怎么改代码，
基础的业务逻辑就是无可更改的，天王老子来了该写的逻辑就是要写，该看的逻辑还是要看，策略模式更像是整理代码的一种方法，
就是不用也没法“俯视”所有逻辑。这也是一种全新的理解。</br>
</p>

<P style="text-indent:2em;">
不大喜欢一些理论性质的解释，直接样例理解，自己更能懂</br>
</p>

### 🏀代码样例
<P style="text-indent:2em;">
首先要有一个接口，里面要包含用于判断每个业务的不同，每个业务具体的实现的方法，比如要计算快递的收费,
就要有一个判断每个快递的类型的方法，每一种快递到底是如何计费的。</br>
</p>

```java
/**
 * 策略模式接口设计
 */
public interface LogisticsService {

    /**
     * 1️⃣需要用来判断具体走那个逻辑
     */
    boolean isCurrentLogistics(Integer type);

    /**
     * 2️⃣计算逻辑
     */
    BigDecimal calculateFee(TransferFeeRequest transferFeeRequest);
}
```

<P style="text-indent:2em;">
同时具体如何计费，就要有快递的运输距离，单价，最重要的快递类型，这些都是具体的业务，参数到底如何写是业务决定的，
也可以有快递的重量，体积，形状等，每家快递公司的收费标准不一样，还有一些政策更改，体量优惠减免，是否有保价，
都会决定具体的逻辑。
</p>

```java
@Data
public class TransferFeeRequest {

    /**
     * 距离
     */
    private BigDecimal distance;

    /**
     * 单价
     */
    private BigDecimal unitPrice;

    /**
     * 快递类型
     */
    private Integer type;
}
```

一般这种业务都是写成具体的服务，比如合作的快递公司有京东、顺丰、圆通、中通，那就是四个服务

=== "京东快递服务"

    ``` java
    /**
     * JD快递服务
     */
    @Service
    public class JDTransfercompany implements LogisticsService {
        private final BigDecimal pickFee = BigDecimal.TEN;

        private final BigDecimal minDistance = BigDecimal.valueOf(80);

        @Override
        public BigDecimal calculateFee(TransferFeeRequest transferFeeRequest) {
            BigDecimal distance = minDistance.compareTo(transferFeeRequest.getDistance()) > 0 ?
                    minDistance : transferFeeRequest.getDistance();
            // do business
            return distance.multiply(transferFeeRequest.getUnitPrice()).add(pickFee);
        }

        @Override
        public boolean isCurrentLogistics(Integer type) {
            return Objects.equals(type, 1);
        }
    }
    ```

=== "顺丰快递服务"

    ``` java
    /**
     * 顺丰快递服务
     */
    @Service
    public class SFTransfercompany implements LogisticsService {
        private final BigDecimal pickFee = BigDecimal.TEN;

        private final BigDecimal minDistance = BigDecimal.valueOf(60);

        @Override
        public BigDecimal calculateFee(TransferFeeRequest transferFeeRequest) {
            BigDecimal distance = minDistance.compareTo(transferFeeRequest.getDistance()) > 0 ?
                    minDistance : transferFeeRequest.getDistance();
            // do business
            return distance.multiply(transferFeeRequest.getUnitPrice()).add(pickFee);
        }

        @Override
        public boolean isCurrentLogistics(Integer type) {
            return Objects.equals(type, 2);
        }
    }
    ```

=== "中通快递服务"

    ``` java
    /**
     * 中通快递服务
     */
    @Service
    public class ZTTransfercompany implements LogisticsService {
        private final BigDecimal pickFee = BigDecimal.TEN;

        private final BigDecimal minDistance = BigDecimal.valueOf(40);

        @Override
        public BigDecimal calculateFee(TransferFeeRequest transferFeeRequest) {
            BigDecimal distance = minDistance.compareTo(transferFeeRequest.getDistance()) > 0 ? 
                    minDistance : transferFeeRequest.getDistance();
            // do business
            return distance.multiply(transferFeeRequest.getUnitPrice()).add(pickFee);
        }

        @Override
        public boolean isCurrentLogistics(Integer type) {
            return Objects.equals(type, 3);
        }
    }
    ```

=== "圆通快递服务"

    ```java
    /**
     * 圆通快递服务
     */
    @Service
    public class YTTransfercompany implements LogisticsService {
        private final BigDecimal pickFee = BigDecimal.TEN;

        private final BigDecimal minDistance = BigDecimal.valueOf(20);

        @Override
        public BigDecimal calculateFee(TransferFeeRequest transferFeeRequest) {
            BigDecimal distance = minDistance.compareTo(transferFeeRequest.getDistance()) > 0 ?
                    minDistance : transferFeeRequest.getDistance();
            // do business
            return distance.multiply(transferFeeRequest.getUnitPrice()).add(pickFee);
        }

        @Override
        public boolean isCurrentLogistics(Integer type) {
            return Objects.equals(type, 4);
        }
    }
    ```

都是类似的，本来可能是if-else一撸到底，现在变成分开实现(例子只是例子，比较简)</br>

那我们在使用的时候就简单一些了,用stream流就能调用</br>

### 🐔使用方式

```java hl_lines="8 9 10 11"
    /**
     * 策略模式需要把所有的可能都注入进来
     */
    private final List<LogisticsService> logisticsServices;

    public BigDecimal calculateFee(@RequestBody TransferFeeRequest transferFeeRequest) {
        // 遍历，根据每个类中的具体实现类来判断到底走那个逻辑
        LogisticsService logisticsService = logisticsServices.stream()
                .filter(logistics -> logistics.isCurrentLogistics(transferFeeRequest.getType()))
                .findFirst()
                .orElse(null);
        // 一定要有对应匹配为空对不上的兜底逻辑,也可以单独列出一个实现类来写
        if (logisticsService == null) {
            throw new RuntimeException("没有对应的快递计算方式");
        }
        return logisticsService.calculateFee(transferFeeRequest);
    }
```

我现在也只讲设计模式如何用，使用场景等，但是对它的理解实在是见仁见智了。其他理论化的介绍就不写了。

## ❷策略模式结合工厂方法模式